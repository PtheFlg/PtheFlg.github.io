<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="referrer" content="no-referrer" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false,"b2t":true,"scrollpercent":20},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="字符串，嗯，面试的重点，多少都会涉及。而且字符串看似简单，其实要深入JVM理解字符串还是有些难度的，所以这一章就来单独说一下字符串的小坑。">
<meta property="og:type" content="article">
<meta property="og:title" content="深入字符串">
<meta property="og:url" content="http://example.com/2022/06/02/String/index.html">
<meta property="og:site_name" content="PtheF-Hexo-Blog">
<meta property="og:description" content="字符串，嗯，面试的重点，多少都会涉及。而且字符串看似简单，其实要深入JVM理解字符串还是有些难度的，所以这一章就来单独说一下字符串的小坑。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-02T07:21:39.000Z">
<meta property="article:modified_time" content="2022-06-02T09:18:37.037Z">
<meta property="article:author" content="PtheF">
<meta property="article:tag" content="java">
<meta property="article:tag" content="底层">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/06/02/String/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>深入字符串 | PtheF-Hexo-Blog</title>
  <meta name="referrer" content="no-referrer"/>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">PtheF-Hexo-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">有点意思</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/02/String/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hexo_avatar.jpeg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PtheF-Hexo-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入字符串
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-02 15:21:39 / 修改时间：17:18:37" itemprop="dateCreated datePublished" datetime="2022-06-02T15:21:39+08:00">2022-06-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>字符串，嗯，面试的重点，多少都会涉及。而且字符串看似简单，其实要深入JVM理解字符串还是有些难度的，所以这一章就来单独说一下字符串的小坑。</p>
<span id="more"></span>

<h1 id="1-String基础"><a href="#1-String基础" class="headerlink" title="1. String基础"></a>1. String基础</h1><h2 id="1-1-String基本特性"><a href="#1-1-String基本特性" class="headerlink" title="1.1 String基本特性"></a>1.1 String基本特性</h2><ul>
<li><p>String 不是基础数据类型，即便他能 String x &#x3D; “” 直接赋值</p>
</li>
<li><p>String 实现了 Comparable 和 Serializable，也就是可以序列化和比大小</p>
</li>
<li><p>String 被final 修饰不能继承</p>
</li>
<li><p>String 在 jdk8之前他的底层是char[] value,jdk9 以后修改成了byte[] value，为啥？</p>
</li>
</ul>
<h2 id="1-2-jdk8-9-对于String底层的修改"><a href="#1-2-jdk8-9-对于String底层的修改" class="headerlink" title="1.2 jdk8 9 对于String底层的修改"></a>1.2 jdk8 9 对于String底层的修改</h2><p>jdk8以前String底层是char数组，jdk9就变成了byte数组，为啥？</p>
<p>首先，可以去官网看：<u><span spellcheck="false" class="md-link md-pair-s"><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/254">JEP 254: Compact Strings</a></span></u> 里面的motivation详细说了，这里概括一下：</p>
<p>以前的java实现String 里面采用 char[] value的形式存储字符串，一个字符 占两个字节，然后String 是堆空间里面主要的存储单位，数量特别多。但是他们发现，大部分的字符串包含的都是一些 Latin-1(拉丁，简单理解，拼音) 字符，这些字符其实一个字节就可以表示了，也就是说，大部分情况下，字符串里面一半的空间都被浪费了。</p>
<p>那么问题又来了，有的时候的确要存非拉丁字符，比如汉字，这咋整，他们在String里面又存储了charset 字段用来保存这个字符的编码，按照编码来分配是一个字节存还是两个字节存。</p>
<p>凡是和String有关系的类，比如 StringBuilder StringBuffer 底层都变成了 byte[]。</p>
<h2 id="1-3-String-的不可变"><a href="#1-3-String-的不可变" class="headerlink" title="1.3 String 的不可变"></a>1.3 String 的不可变</h2><p>什么鬼，忘得特别干净，复习一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量赋值：  </span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 创建字符串，只要是这种通过字面量创建出来的字符串，他们的值都是存在字符串常量池中的，而且字符串常量池中不允许重复  </span></span><br><span class="line"><span class="comment">// 所以如果两个字符串通过字面量赋值相同，那么这两个字符串其实指向的是同一个地址，俩字符串的hashcode 相同。  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// 这里肯定是 true  </span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 如果对这种字符串进行重新赋值，他并不会修改常量池中的值，而是重新造一个值，然后改变指向，这就体现了字符串的不可变  </span></span><br><span class="line"><span class="comment">// 同理 字符串拼接，也是一个道理，并不是修改值，而是重新造一个值并修改指向  </span></span><br><span class="line"><span class="comment">// 包括 String.replace(old, new)，这个也是新造，不是修改。  </span></span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// 这回就是 false，因为s1 已经改变了指向  </span></span><br><span class="line">​  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 下面这个，s 还是 hello，别问，不知道为啥，但是如果直接在main 方法里面设置 s = &quot;test&quot;，他是可以修改成功的  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);  </span><br><span class="line">    change(s);  </span><br><span class="line">    System.out.println(s);  </span><br><span class="line">&#125;  </span><br><span class="line">​  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String s)</span>&#123;  </span><br><span class="line">    s = <span class="string">&quot;test&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-字符串常量池"><a href="#1-4-字符串常量池" class="headerlink" title="1.4 字符串常量池"></a>1.4 字符串常量池</h2><ul>
<li><p>字符串常量池：String Pool 或者也叫 StringTable 是一个固定大小的HashMap，HashMap 总学过吧。默认大小是 1009 (jdk6)，如果存入的字符串过多，那么得到的HashKey也就会很多，从而导致链表过长，然后效率降低。</p>
</li>
<li><p>使用 <code>-XX:StringTableSize</code> 来指定常量池的大小。</p>
</li>
<li><p>jdk6中默认是 1009，固定的，可以通过参数修改，如果字符串过多则效率降低</p>
</li>
<li><p>jdk7以后默认就是60013，1009 是设置的最小长度</p>
</li>
</ul>
<h1 id="2-字符串拼接"><a href="#2-字符串拼接" class="headerlink" title="2. 字符串拼接"></a>2. 字符串拼接</h1><p>详细的说一说字符串拼接的操作, 当然也是介绍概念：</p>
<ul>
<li><p>常量和常量拼接结果在常量池，原理是编译期优化</p>
</li>
<li><p>常量池中不会重复</p>
</li>
<li><p>只要拼接的东西里面有一个是变量，那么拼接结果就放在堆里面，变量拼接原理是StringBuilder</p>
</li>
<li><p>如果拼接的结果调用inturn() 方法，则主动将常量池中还没有的字符串对象放入池中，返回地址</p>
</li>
</ul>
<p>然后我们一个一个说：</p>
<h2 id="2-1-常量拼接常量结果在常量池"><a href="#2-1-常量拼接常量结果在常量池" class="headerlink" title="2.1 常量拼接常量结果在常量池"></a>2.1 常量拼接常量结果在常量池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s1 是常量拼接字符串，所以他的结果在常量池里面，所以s1 == s2 是 true  </span></span><br><span class="line"><span class="comment">// 而且，如果我们把编译出来的class文件在idea里面打开，让idea 给我们做反编译，我们就会看到  </span></span><br><span class="line"><span class="comment">// s1 里面写的根本不是拼接操作，而是直接 String s1 = &quot;abc&quot;;  </span></span><br><span class="line"><span class="comment">// 这个就是编译期优化，他在编译的时候，发现你常量拼接，他就直接给你转化成拼接结果了。  </span></span><br><span class="line">​  </span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="string">&quot;c&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line">System.out.println(s1 == s2);  </span><br><span class="line">System.out.println(s1.equals(s2));</span><br></pre></td></tr></table></figure>

<h2 id="2-2-拼接变量结果入堆"><a href="#2-2-拼接变量结果入堆" class="headerlink" title="2.2 拼接变量结果入堆"></a>2.2 拼接变量结果入堆</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;  </span><br><span class="line">​  </span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javahadoop&quot;</span>;  </span><br><span class="line"><span class="comment">// 什么是编译期优化，就是两个字面值的字符串做拼接，在javac编译的时候就已经可以知道拼接结果了</span></span><br><span class="line"><span class="comment">// 那么他就会在编译的时候就给你把值赋好</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span> + <span class="string">&quot;hadoop&quot;</span>; <span class="comment">// 编译期优化，等同于 s4 = &quot;javahadoop&quot;;  </span></span><br><span class="line"></span><br><span class="line">s3 == s4  <span class="comment">// true，且 s3 和 s4 都指向了字符串常量池中的javahadoop</span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 这里拼接出现了变量，如果我们去看字节码就会发现，他这里会创建一个StringBuilder给你进行拼接操作</span></span><br><span class="line"><span class="comment">// 然后拼接完成后给你return StringBuilder.toString(); </span></span><br><span class="line"><span class="comment">// 然后这个 toString() 方法会new String().</span></span><br><span class="line"><span class="comment">// 所以四舍五入就相当于在堆中 new String(),拼接结果位 javahadoop  </span></span><br><span class="line"><span class="comment">// 也就是，下面三个，都是独立的对象，那肯定是不相等了。  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span> + s2;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;  </span><br><span class="line"></span><br><span class="line">s3 == s5; <span class="comment">// false，而且s3和 s5 s6 s7 都不相等，愿意你很简单，一个是字符串常量池，另外的是堆中对象</span></span><br><span class="line">s5 == s6; <span class="comment">// false  </span></span><br><span class="line">s5 == s7; <span class="comment">// false  </span></span><br><span class="line">s6 == s7; <span class="comment">// false</span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// s6 是 javahadoop 是吧，很好，intern()就是判断常量池里面有没有 javahadoop，  </span></span><br><span class="line"><span class="comment">// 如果存在，则返回他的地址，如果不存在，则在常量池中创建一个，然后返回他的地址。  </span></span><br><span class="line"><span class="comment">// 至于这个intern方法后面会专门说。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();   </span><br><span class="line">​  </span><br><span class="line">s3 == s8; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="3-变量拼接的底层原理"><a href="#3-变量拼接的底层原理" class="headerlink" title="3. 变量拼接的底层原理"></a>3. 变量拼接的底层原理</h1><p>我们写一个变量拼接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">a3</span> <span class="operator">=</span> a1 + a2;</span><br></pre></td></tr></table></figure>

<p>然后我们看他的字节码文件，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">00 ldc #10 &lt;abc&gt;</span><br><span class="line">02 astore_0</span><br><span class="line">03 ldc #11 &lt;def&gt;</span><br><span class="line">05 astore_1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面就对应a1 和 a2 的赋值操作，不说了，主要是下面：</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先new一个StringBuilder</span></span><br><span class="line">06 new #12 &lt;java/lang/StringBuilder&gt;</span><br><span class="line">09 dup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后调用构造函数</span></span><br><span class="line">10 invokespecial #13 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取局表的0位也就是 a1</span></span><br><span class="line">13 aload_0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用了StringBuilder的 append 方法，把a1传入</span></span><br><span class="line">14 invokevirtual #14 &lt;java/lang/StringBuilder.append :...;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取局表1位也就是a2</span></span><br><span class="line">17 aload_1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同理调用append方法</span></span><br><span class="line">18 invokevirtual #14 &lt;java/lang/StringBuilder.append : ...;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再调用toString 方法,这个toString 方法比较特殊，他的实现是 <span class="built_in">return</span> new String();</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所以 toString 约等于 new String() 为啥说约等于，以后再说。</span></span><br><span class="line">21 invokevirtual #15 &lt;java/lang/StringBuilder.toString : ...;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把结果存储到局表2位</span></span><br><span class="line">24 astore_2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">剩下就是输出了</span></span><br><span class="line">25 getstatic #2 &lt;java/lang/System.out :...;&gt;</span><br><span class="line">28 aload_2</span><br></pre></td></tr></table></figure>

<p>注意，用StringBuilder底层去拼接的，必须是变量，可不是说必须是引用，举个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span> + <span class="string">&quot;def&quot;</span>;  </span><br><span class="line">​  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 这个，它仅仅是应用，而不是变量，所以这种情况下他也不会用StringBuilder来构建  </span></span><br><span class="line"><span class="comment">// 所以这里仍旧会进行编译期优化  </span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-执行效率问题"><a href="#3-1-执行效率问题" class="headerlink" title="3.1 执行效率问题"></a>3.1 执行效率问题</h2><p>直接创建StringBuilder来拼接肯定是快，而且快很多，所以我们要字符串拼接我们不如直接创建一个StringBuilder或者StringBuffer来得实在。</p>
<p>默认情况下 StringBuilder的容量是16，如果不够了会进行扩容，也消耗性能，所以我们尽可能的给他确定一下容量。</p>
<h2 id="3-2-创建对象数"><a href="#3-2-创建对象数" class="headerlink" title="3.2 创建对象数"></a>3.2 创建对象数</h2><p>我们创建一个字符串：<code>new String(&quot;abc&quot;)</code>，这行代码创建了几个对象。很好，遇事不决字节码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一步，创建一个 String，也就是 new</span></span><br><span class="line">00 new #16 &lt;java/lang/String&gt;</span><br><span class="line">03 dup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后，在常量池里面创建字符串 <span class="string">&quot;abc&quot;</span>,然后把 abc 传入 构造函数</span></span><br><span class="line">04 ldc #10 &lt;abc&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用构造，根据常量池里面的字符串在堆中创建对象</span></span><br><span class="line">06 invokespecial #17 &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;</span><br><span class="line">09 astore_0</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure>

<p>所以这么来看创建了几个对象？很显然是两个：一个是堆中的String，一个是常量池中的abc。</p>
<p>然后再说一下这个常量池的问题，为啥这里创建String的时候会在常量池中也创建一个？我个人觉得是因为我们传入的是一个字面量的字符串，所以他会把这个字面量存入常量池。</p>
<h2 id="3-3-更高级的对象数问题"><a href="#3-3-更高级的对象数问题" class="headerlink" title="3.3 更高级的对象数问题"></a>3.3 更高级的对象数问题</h2><p>一行代码：<code>String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code> ，这行代码创建了几个对象。同理，于是不决字节码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 创建 StringBuilder 对象，用来待会的拼接操作</span></span><br><span class="line">00 new #5 &lt;java/lang/StringBuilder&gt;</span><br><span class="line">03 dup</span><br><span class="line">04 invokespecial #6 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.创建 String 对象，对应 new String(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line">07 new #2 &lt;java/lang/String&gt;</span><br><span class="line">10 dup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.在字符串常量池里面创建 <span class="string">&quot;a&quot;</span></span></span><br><span class="line">11 ldc #7 &lt;a&gt;</span><br><span class="line">13 invokespecial #4 &lt;java/lang/String.&lt;init&gt; :...&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里 StringBuilder 进行了 append操作。</span></span><br><span class="line">16 invokevirtual #8 &lt;java/lang/StringBuilder.append :...;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.创建String对象，对应 new String(<span class="string">&quot;b&quot;</span>);</span></span><br><span class="line">19 new #2 &lt;java/lang/String&gt;</span><br><span class="line">22 dup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5.常量池里面创建 <span class="string">&quot;b&quot;</span></span></span><br><span class="line">23 ldc #9 &lt;b&gt;</span><br><span class="line">25 invokespecial #4 &lt;java/lang/String.&lt;init&gt; : ...&gt;</span><br><span class="line">28 invokevirtual #8 &lt;java/lang/StringBuilder.append :  ...;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6.StringBuilder 调用 toString 方法，这里又创建一个 String</span></span><br><span class="line">31 invokevirtual #10 &lt;java/lang/StringBuilder.toString : ...;&gt;</span><br><span class="line">34 astore_0</span><br><span class="line">35 return</span><br></pre></td></tr></table></figure>

<p>根据上面的解析，可以知道，一个语句总共创建了6个对象，只得注意的是，最终结果是 “ab”，但是直到最后 常量池里面也没有 “ab” 这个字符串，虽然说在toString 里面创建了字符串，通过 new String() ，我们之前说 new String(xxx) 会在pool中创建xxx，但是这里为啥就不创建了？我觉得是因为构造函数里面传入的不是字面量了，而是变量，所以不会再创建ab常量了。</p>
<h1 id="4-intern方法"><a href="#4-intern方法" class="headerlink" title="4. intern方法"></a>4. intern方法</h1><p>可以去String类里面看看他的注释，全英语的，反正我看不懂，所以下面大致给说一下</p>
<h2 id="intern-方法介绍"><a href="#intern-方法介绍" class="headerlink" title="intern 方法介绍"></a>intern 方法介绍</h2><p>首先，本地方法。</p>
<p>一个不是用字面量创建的字符串(注意，不是字面量创建的)，调用这个方法，他就会去 pool 里面找，有没有和当前字符串相等的字符串常量，如果有，则返回这个字符串的引用；如果没有，则在pool里面创建一个，然后返回引用。</p>
<p>如果有两个字符串 s t, s.intern() &#x3D;&#x3D; t.intern() 成立，当且仅当 s.equals(t) 成立。</p>
<p>举个例子：</p>
<p><code>String s = new String(&quot;hello world&quot;).intern()</code></p>
<p>这行代码就是：堆中创建了一个 字符串 “hello world”，然后调用 intern 去看 StringTable 里面有没有 helloworld，如果没有，则创建一个，然后返回引用给s。</p>
<p>再看一个例子：</p>
<p><code>(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;</code></p>
<p>这个必然是 true，因为在 最前面拼接的时候，就已经在pool里面创建了”abc”。</p>
<p>所以总结一下，就是去字符串常量池中找有没有当前字符串的字面量常量，如果有则返回，如果没有则创建后返回。总之执行完这个方法，可以保证返回的东西指向了字符串常量池。</p>
<h1 id="5-一道String面试题"><a href="#5-一道String面试题" class="headerlink" title="5. 一道String面试题"></a>5. 一道String面试题</h1><p>上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">// 首先，创建了 s1，堆中一个，pool中一个，都是 &quot;a&quot;  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 这条代码是在pool中创建对象，但是已经有了，所以这行没用，同时他没有接收，s1 不变。  </span></span><br><span class="line">s1.intern();  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 又创建了一个对象，指向pool中的 &quot;a&quot;  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 所以这个没有异议，肯定是 false  </span></span><br><span class="line"><span class="comment">// jdk6/7/8   false  </span></span><br><span class="line">System.out.println(s1 == s2);            </span><br><span class="line">​  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 这里就开始扯淡了，看这行代码，创建了一堆对象，常量池中的 &quot;a&quot; 堆中的 &quot;a&quot;,  </span></span><br><span class="line"><span class="comment">// s3 是堆中的 aa，但常量池中可没有aa，老生常谈了，上面就重点说过。  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 然后在常量池中创建 &quot;aa&quot;,这里就开始有区别了，  </span></span><br><span class="line"><span class="comment">// jdk6 中，常量池在永久代里面，和堆没半毛钱关系，所以就是你想的那样，在pool中创建了 &quot;aa&quot;  </span></span><br><span class="line"><span class="comment">// 然后s4是常量池中的，s3 是堆中的，没关系，所以结果是 false。  </span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 而jdk7/8 不一样，jdk7/8的常量池在堆中，他在常量池创建对象的时候，一看，哎，  </span></span><br><span class="line"><span class="comment">// 堆里面已经有了一个对象(注意是堆中，不是常量池中)，所以他为了节省资源，他不会在常量池中再次创建对象，  </span></span><br><span class="line"><span class="comment">// 而是在常量池中创建一个引用，这个引用指向堆中，在这里就是s3,  </span></span><br><span class="line"><span class="comment">// 最后的结果就是，s4 指向常量池中的那个值，结果常量池中的值指向了s3，相当于 s4 变相的指向了 s3.  </span></span><br><span class="line"><span class="comment">// 所以结果是 true  </span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 但是注意，jdk7/8 中这种从常量池指向堆这种行为，只有 intern() 才会触发，  </span></span><br><span class="line"><span class="comment">// 你正常的 s5 = &quot;aa&quot;; 他是不会触发这种指向的，他还是会正常的在常量池中创建。  </span></span><br><span class="line">s3.intern();  </span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;  </span><br><span class="line"><span class="comment">// jdk6 false   jdk7/8 true  </span></span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure>

<h2 id="变式"><a href="#变式" class="headerlink" title="变式"></a>变式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这回的结果就是 false，原因很简单，根据上面的叙述，常量池引用堆只有intern才会触发，  </span></span><br><span class="line"><span class="comment">// 这里改变顺序，先创建 s2，这里就会在常量池中创建 &quot;aa&quot;,然后intern() 就会发现已经存在 &quot;aa&quot;，就不会指向堆。  </span></span><br><span class="line"><span class="comment">// 所以 s1 和 s2 是两个不同的对象，结果是false  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);  </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;  </span><br><span class="line">s1.intern();  </span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>

<h2 id="总结-intern-的使用："><a href="#总结-intern-的使用：" class="headerlink" title="总结 intern 的使用："></a>总结 intern 的使用：</h2><h3 id="jdk6"><a href="#jdk6" class="headerlink" title="jdk6"></a>jdk6</h3><ul>
<li><p>如果池中有，则不会创建，而是返回地址</p>
</li>
<li><p>池中没有，把当前字符串拷贝一份放入池中</p>
</li>
</ul>
<h3 id="jdk7-x2F-8"><a href="#jdk7-x2F-8" class="headerlink" title="jdk7&#x2F;8"></a>jdk7&#x2F;8</h3><ul>
<li><p>池中有，则返回地址，和上面一样</p>
</li>
<li><p>池中没有，则拷贝当前字符串的地址放到池中，让池指向堆，节约空间，然后返回地址。</p>
</li>
</ul>
<h1 id="6-G1的String去重行为"><a href="#6-G1的String去重行为" class="headerlink" title="6. G1的String去重行为"></a>6. G1的String去重行为</h1><blockquote>
<p>首先说一下G1，简单说，就是jdk7以后jvm里面的一个垃圾回收器。</p>
<p>这个gc并不分minor gc 还是 major gc，我查了一下，他似乎是一个整体的垃圾回收器，然后里面细分为回收年轻代 老年代等的行为。所以G1(G First) 就是一个全局的垃圾回收器。</p>
</blockquote>
<p>明确一个概念，这里的去重，当然不是指的字符串常量池中去重，pool中本来就没有重复对象，这个去重指的是堆中去重。</p>
<h2 id="6-1-去重的背景"><a href="#6-1-去重的背景" class="headerlink" title="6.1 去重的背景"></a>6.1 去重的背景</h2><p>对于许多java应用，经过测试发现如下：</p>
<ul>
<li><p>堆存活数据集合里面String 对象占25%</p>
</li>
<li><p>堆存活数据集合里面重复的String 占 13%</p>
</li>
<li><p>String 平均长度 45</p>
</li>
</ul>
<h2 id="6-2-实现"><a href="#6-2-实现" class="headerlink" title="6.2 实现"></a>6.2 实现</h2><ul>
<li><p>当垃圾收集器工作时会访问堆上的存活对象，检查是否是候选的去重字符串</p>
</li>
<li><p>如果是，把字符串加入一个队列，一个去重的后台线程对这个队列进行处理，处理就是删除队列元素然后尝试进行去重操作</p>
</li>
<li><p>使用一个hashtable来记录所有被String使用的不重复的char数组(就是String底层的char数组，去重主要是去重这个)，进行去重的时候会去查这个char数组，来检查堆上是否已经存在了一个一模一样的char数组。</p>
</li>
<li><p>如果存在，那么当前String就会改为引用已有的那个char数组，它本身的那个char数组会被释放。</p>
</li>
<li><p>如果不存在，那么当前char数组进入hashtable，然后对下一个String去重。</p>
</li>
</ul>
<h2 id="6-3-开启"><a href="#6-3-开启" class="headerlink" title="6.3 开启"></a>6.3 开启</h2><p>UseStringDeduplication(boolean) 开启String去重，默认是不开启的。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/%E5%BA%95%E5%B1%82/" rel="tag"># 底层</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/06/02/JIT/" rel="prev" title="JIT即时编译器">
      <i class="fa fa-chevron-left"></i> JIT即时编译器
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/06/02/garbage-collect/" rel="next" title="垃圾回收">
      垃圾回收 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-String%E5%9F%BA%E7%A1%80"><span class="nav-text">1. String基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-String%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-text">1.1 String基本特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-jdk8-9-%E5%AF%B9%E4%BA%8EString%E5%BA%95%E5%B1%82%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-text">1.2 jdk8 9 对于String底层的修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-String-%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="nav-text">1.3 String 的不可变</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-text">1.4 字符串常量池</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="nav-text">2. 字符串拼接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%B8%B8%E9%87%8F%E6%8B%BC%E6%8E%A5%E5%B8%B8%E9%87%8F%E7%BB%93%E6%9E%9C%E5%9C%A8%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-text">2.1 常量拼接常量结果在常量池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E6%8B%BC%E6%8E%A5%E5%8F%98%E9%87%8F%E7%BB%93%E6%9E%9C%E5%85%A5%E5%A0%86"><span class="nav-text">2.2 拼接变量结果入堆</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%8F%98%E9%87%8F%E6%8B%BC%E6%8E%A5%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">3. 变量拼接的底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98"><span class="nav-text">3.1 执行效率问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%95%B0"><span class="nav-text">3.2 创建对象数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%95%B0%E9%97%AE%E9%A2%98"><span class="nav-text">3.3 更高级的对象数问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-intern%E6%96%B9%E6%B3%95"><span class="nav-text">4. intern方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#intern-%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="nav-text">intern 方法介绍</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E4%B8%80%E9%81%93String%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">5. 一道String面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E5%BC%8F"><span class="nav-text">变式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-intern-%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="nav-text">总结 intern 的使用：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk6"><span class="nav-text">jdk6</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk7-x2F-8"><span class="nav-text">jdk7&#x2F;8</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-G1%E7%9A%84String%E5%8E%BB%E9%87%8D%E8%A1%8C%E4%B8%BA"><span class="nav-text">6. G1的String去重行为</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E5%8E%BB%E9%87%8D%E7%9A%84%E8%83%8C%E6%99%AF"><span class="nav-text">6.1 去重的背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%AE%9E%E7%8E%B0"><span class="nav-text">6.2 实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E5%BC%80%E5%90%AF"><span class="nav-text">6.3 开启</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Author"
      src="/images/hexo_avatar.jpeg">
  <p class="site-author-name" itemprop="name">Author</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/PtheF" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PtheF" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Author</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
